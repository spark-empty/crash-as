/**
    @file             Can_Cfg.h
    @version          2.0.0

    @brief            AUTOSAR Can module interface
    @details          Configuration settings generated by user settings.

    Project           AUTOSAR 3.0 MCAL
    Platform          PA
    Peripheral        FLEXCAN
    Dependencies      

    ARVersion         3.0.0
    ARRevision        ASR_REL_3_0_REV_0003
    ARConfVariant
    SWVersion         2.0.0
    BuildVersion      XPC563xM_MCAL_2_0_0_RTM_ASR_REL_3_0_REV_0003_20111223

    (c) Copyright 2006-2011 Freescale Semiconductor Inc. & STMicroelectronics
    All Rights Reserved.
*/
/*==================================================================================================
==================================================================================================*/


/**
@file    Can_Cfg.h
@brief   (CAN023) The consistency of the configuration must be checked by the configuration tool(s).
@brief   (CAN022) The code configurator of the Can module is CAN controller specific.
         If the CAN controller is sited on-chip, the code generation tool for the Can module is Controller specific.
         If the CAN controller is an external device the generation tool must not be Controller specific.
@brief   (CAN024) The valid values that can be configured are hardware dependent.
         Therefore the rules and constraints can't be given in the standard.
         The configuration tool is responsible to do a static configuration checking, also regarding dependencies between modules (i.e. Port driver, MCU driver etc.)
@remarks Covers CAN023, CAN022, CAN024
@remarks Implements DCAN00023, DCAN00022, DCAN00024
*/

#ifndef _CAN_CFG_H_
#define _CAN_CFG_H_


/*==================================================================================================
                                    SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
@{
@brief    The integration of incompatible files shall be avoided.
*/
#define CAN_AR_MAJOR_VERSION_CFG_H  3
#define CAN_AR_MINOR_VERSION_CFG_H  0
#define CAN_AR_PATCH_VERSION_CFG_H  0
#define CAN_SW_MAJOR_VERSION_CFG_H  2
#define CAN_SW_MINOR_VERSION_CFG_H  0
#define CAN_SW_PATCH_VERSION_CFG_H  0
/**@}*/


[!NOCODE!]
[!/* Check if the number of Controllers is the same in all Config Sets */!]
[!VAR "z"="0"!]
[!VAR "x"="num:i(count(CanConfigSet/*[1]/CanController/*))"!]
[!LOOP "CanConfigSet/*"!]
    [!VAR "y"="num:i(count(node:current()/CanController/*))"!]
    [!IF "($y = $x)"!]
        [!VAR "z"="@name"!]
    [!ELSE!]
        [!WARNING!] Number of CanControllers (=[!"$y"!]) in [!"@name"!] is different from Number of CanControllers [!"$x"!] in (= [!"$z"!]).[!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

[!/* Check if the settings for Rx/Tx/BusOff/WakeUp processing is the same for all Config sets (because are pre-compile parameters) */!]
[!VAR "cs"="num:i(count(CanConfigSet/*))"!]
[!IF "$cs>1"!]
    [!VAR "rxproc_a"="0"!][!VAR "txproc_a"="0"!][!VAR "boproc_a"="0"!][!VAR "wuproc_a"="0"!]
    [!VAR "rxproc_b"="0"!][!VAR "txproc_b"="0"!][!VAR "boproc_b"="0"!][!VAR "wuproc_b"="0"!]
    [!VAR "rxproc_c"="0"!][!VAR "txproc_c"="0"!][!VAR "boproc_c"="0"!][!VAR "wuproc_c"="0"!]
    [!VAR "rxproc_d"="0"!][!VAR "txproc_d"="0"!][!VAR "boproc_d"="0"!][!VAR "wuproc_d"="0"!]
    [!VAR "rxproc_e"="0"!][!VAR "txproc_e"="0"!][!VAR "boproc_e"="0"!][!VAR "wuproc_e"="0"!]
    [!VAR "rxproc_f"="0"!][!VAR "txproc_f"="0"!][!VAR "boproc_f"="0"!][!VAR "wuproc_f"="0"!]
    [!/* Get the values from First ConfigSet of these pre-compile parameters */!]
    [!LOOP "CanConfigSet/*[1]/CanController/*"!]
        [!IF "CanHwChannel='FlexCAN_A'"!]
            [!VAR "rxproc_a"="CanRxProcessing"!]
            [!VAR "txproc_a"="CanTxProcessing"!]
            [!VAR "boproc_a"="CanBusoffProcessing"!]
            [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                [!VAR "wuproc_a"="CanWakeupProcessing"!]
            [!ENDIF!]
        [!ELSEIF "CanHwChannel='FlexCAN_B'"!]
            [!VAR "rxproc_b"="CanRxProcessing"!]
            [!VAR "txproc_b"="CanTxProcessing"!]
            [!VAR "boproc_b"="CanBusoffProcessing"!]
            [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                [!VAR "wuproc_b"="CanWakeupProcessing"!]
            [!ENDIF!]
         [!ELSEIF "CanHwChannel='FlexCAN_C'"!]
            [!VAR "rxproc_c"="CanRxProcessing"!]
            [!VAR "txproc_c"="CanTxProcessing"!]
            [!VAR "boproc_c"="CanBusoffProcessing"!]
            [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                [!VAR "wuproc_c"="CanWakeupProcessing"!]
            [!ENDIF!]
         [!ELSEIF "CanHwChannel='FlexCAN_D'"!]
            [!VAR "rxproc_d"="CanRxProcessing"!]
            [!VAR "txproc_d"="CanTxProcessing"!]
            [!VAR "boproc_d"="CanBusoffProcessing"!]
            [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                [!VAR "wuproc_d"="CanWakeupProcessing"!]
            [!ENDIF!]
         [!ELSEIF "CanHwChannel='FlexCAN_E'"!]
            [!VAR "rxproc_e"="CanRxProcessing"!]
            [!VAR "txproc_e"="CanTxProcessing"!]
            [!VAR "boproc_e"="CanBusoffProcessing"!]
            [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                [!VAR "wuproc_e"="CanWakeupProcessing"!]
            [!ENDIF!]
          [!ELSEIF "CanHwChannel='FlexCAN_F'"!]
            [!VAR "rxproc_f"="CanRxProcessing"!]
            [!VAR "txproc_f"="CanTxProcessing"!]
            [!VAR "boproc_f"="CanBusoffProcessing"!]
            [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                [!VAR "wuproc_f"="CanWakeupProcessing"!]
              [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!VAR "rx_a"="0"!][!VAR "tx_a"="0"!][!VAR "bo_a"="0"!][!VAR "wu_a"="0"!]
    [!VAR "rx_b"="0"!][!VAR "tx_b"="0"!][!VAR "bo_b"="0"!][!VAR "wu_b"="0"!]
    [!VAR "rx_c"="0"!][!VAR "tx_c"="0"!][!VAR "bo_c"="0"!][!VAR "wu_c"="0"!]
    [!VAR "rx_d"="0"!][!VAR "tx_d"="0"!][!VAR "bo_d"="0"!][!VAR "wu_d"="0"!]
    [!VAR "rx_e"="0"!][!VAR "tx_e"="0"!][!VAR "bo_e"="0"!][!VAR "wu_e"="0"!]
    [!VAR "rx_f"="0"!][!VAR "tx_f"="0"!][!VAR "bo_f"="0"!][!VAR "wu_f"="0"!]
    [!/* Processing modes are Pre-compile parameters -> MUST have the same values in all CanConfigSet's  */!]
    [!LOOP "CanConfigSet/*"!]
        [!LOOP "CanController/*"!]
            [!IF "CanHwChannel='FlexCAN_A'"!]
                [!VAR "rx_a"="CanRxProcessing"!]
                [!IF "($rxproc_a!=$rx_a)"!]
                    [!ERROR!] CanRxProcessing must have the same values for Can_A in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "tx_a"="CanTxProcessing"!]
                [!IF "($txproc_a!=$tx_a)"!]
                    [!ERROR!] CanTxProcessing must have the same values for Can_A in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "bo_a"="CanBusoffProcessing"!]
                [!IF "($boproc_a!=$bo_a)"!]
                    [!ERROR!] CanBusoffProcessing must have the same values for Can_A in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                    [!VAR "wu_a"="CanWakeupProcessing"!]
                    [!IF "($wuproc_a!=$wu_a)"!]
                        [!ERROR!] CanWakeupProcessing must have the same values for Can_A in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ELSEIF "CanHwChannel = 'FlexCAN_B'"!]
                [!VAR "rx_b"="CanRxProcessing"!]
                [!IF "($rxproc_b!=$rx_b)"!]
                    [!ERROR!] CanRxProcessing must have the same values for Can_B in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "tx_b"="CanTxProcessing"!]
                [!IF "($txproc_b!=$tx_b)"!]
                    [!ERROR!] CanTxProcessing must have the same values for Can_B in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "bo_b"="CanBusoffProcessing"!]
                [!IF "($boproc_b!=$bo_b)"!]
                    [!ERROR!] CanBusoffProcessing must have the same values for Can_B in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                    [!VAR "wu_b"="CanWakeupProcessing"!]
                    [!IF "($wuproc_b!=$wu_b)"!]
                        [!ERROR!] CanWakeupProcessing must have the same values for Can_B in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ELSEIF "CanHwChannel = 'FlexCAN_C'"!]
                [!VAR "rx_c"="CanRxProcessing"!]
                [!IF "($rxproc_c!=$rx_c)"!]
                    [!ERROR!] CanRxProcessing must have the same values for Can_C in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "tx_c"="CanTxProcessing"!]
                [!IF "($txproc_c!=$tx_c)"!]
                    [!ERROR!] CanTxProcessing must have the same values for Can_C in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "bo_c"="CanBusoffProcessing"!]
                [!IF "($boproc_c!=$bo_c)"!]
                    [!ERROR!] CanBusoffProcessing must have the same values for Can_C in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                    [!VAR "wu_c"="CanWakeupProcessing"!]
                    [!IF "($wuproc_c!=$wu_c)"!]
                        [!ERROR!] CanWakeupProcessing must have the same values for Can_C in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ELSEIF "CanHwChannel = 'FlexCAN_D'"!]
                [!VAR "rx_d"="CanRxProcessing"!]
                [!IF "($rxproc_d!=$rx_d)"!]
                    [!ERROR!] CanRxProcessing must have the same values for Can_D in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "tx_d"="CanTxProcessing"!]
                [!IF "($txproc_d!=$tx_d)"!]
                    [!ERROR!] CanTxProcessing must have the same values for Can_D in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "bo_d"="CanBusoffProcessing"!]
                [!IF "($boproc_d!=$bo_d)"!]
                    [!ERROR!] CanBusoffProcessing must have the same values for Can_D in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                    [!VAR "wu_d"="CanWakeupProcessing"!]
                    [!IF "($wuproc_d!=$wu_d)"!]
                        [!ERROR!] CanWakeupProcessing must have the same values for Can_D in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ELSEIF "CanHwChannel = 'FlexCAN_E'"!]
                [!VAR "rx_e"="CanRxProcessing"!]
                [!IF "($rxproc_e!=$rx_e)"!]
                    [!ERROR!] CanRxProcessing must have the same values for Can_E in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "tx_e"="CanTxProcessing"!]
                [!IF "($txproc_e!=$tx_e)"!]
                    [!ERROR!] CanTxProcessing must have the same values for Can_E in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "bo_e"="CanBusoffProcessing"!]
                [!IF "($boproc_e!=$bo_e)"!]
                    [!ERROR!] CanBusoffProcessing must have the same values for Can_E in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                    [!VAR "wu_e"="CanWakeupProcessing"!]
                    [!IF "($wuproc_e!=$wu_e)"!]
                        [!ERROR!] CanWakeupProcessing must have the same values for Can_E in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ELSEIF "CanHwChannel = 'FlexCAN_F'"!]
                [!VAR "rx_f"="CanRxProcessing"!]
                [!IF "($rxproc_f!=$rx_f)"!]
                    [!ERROR!] CanRxProcessing must have the same values for Can_F in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "tx_f"="CanTxProcessing"!]
                [!IF "($txproc_f!=$tx_f)"!]
                    [!ERROR!] CanTxProcessing must have the same values for Can_F in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!VAR "bo_f"="CanBusoffProcessing"!]
                [!IF "($boproc_f!=$bo_f)"!]
                    [!ERROR!] CanBusoffProcessing must have the same values for Can_F in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                [!ENDIF!]
                [!IF "CanGeneral/CanWakeupSupport = 'true'"!]
                    [!VAR "wu_f"="CanWakeupProcessing"!]
                    [!IF "($wuproc_f!=$wu_f)"!]
                        [!ERROR!] CanWakeupProcessing must have the same values for Can_F in all CanConfigSets because are Pre-Compile Parameters.[!ENDERROR!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDLOOP!]
[!ENDIF!]

[!ENDNOCODE!]


/**
@{
@brief    Can Controllers. Defines for conversion between object names and object IDs.
          (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file.
*/[!NOCODE!]
[!/* Check if two controllers have the same name in any ConfigSet */!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/*/CanController/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../../*/CanController/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter = 1"!]
        [!CODE!]
/* Default configuration for [!"CanHwChannel"!] */
#define [!"@name"!] (uint8)[!"CanControllerId"!]U
        [!ENDCODE!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDNOCODE!]
/**@}*/


/**
@{
@brief    Can Controller Configurations.
          (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file.
*/[!NOCODE!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/*/CanController/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../../*/CanController/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter = 1"!]
        [!CODE!]
/* Default configuration for CanController ID=[!"num:i(CanControllerId)"!], [!"CanHwChannel"!] */
#define [!"@name"!]_config (uint8)[!"@index"!]U
        [!ENDCODE!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDNOCODE!]
/**@}*/


/**
@{
@brief    HOH - Can Hardware Objects.
          These defines (IDs) are extracted from the CanObjectId paremeter.
@brief    (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file.
@brief    (PR-MCAL-3031)Restriction: The HRHs and the HTHs shall be grouped, where HRHs come first.
          Example: HRH0 - 0, HRH1 - 1, HTH0 - 2, HTH1 - 3
          This must especially be supported for configurations containing several controllers what in this case means that
            the HRHs of all controllers are grouped before the HTHs of all controllers (there must not be any HTH of any controller
            with an object ID lower than that of any HRH configured for this driver).
*/[!NOCODE!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/*/CanHardwareObject/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../../*/CanHardwareObject/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
    [!WARNING!] Some MBs have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDNOCODE!]

[!NOCODE!]
[!LOOP "CanConfigSet/*"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'RECEIVE'"!]
[!CODE!]#define [!"@name"!] [!"num:i(CanObjectId)"!]U /* RECEIVE object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
[!ENDCODE!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDLOOP!]
[!LOOP "CanConfigSet/*"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'TRANSMIT'"!]
[!CODE!]#define [!"@name"!] [!"num:i(CanObjectId)"!]U /* TRANSMIT object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
[!ENDCODE!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDLOOP!]
[!ENDNOCODE!]


[!NOCODE!]
[!LOOP "CanConfigSet/*"!]
    [!VAR "tx_mb_marked" = "0"!]
    [!FOR "canhwobjectid" = "0" TO "num:i(count(CanHardwareObject/*))-1"!]
    [!LOOP "CanHardwareObject/*"!]
       [!IF "CanObjectId = $canhwobjectid"!]
        [!IF "CanObjectType = 'TRANSMIT'"!][!VAR "tx_mb_marked" = "1"!][!ENDIF!]
        [!IF "(CanObjectType = 'RECEIVE') and ($tx_mb_marked = 1)"!]
            [!ERROR!]
                The HRH and HTH Ids are defined under two different name-spaces (Refer to CAN326).
                Example: HRH0-0, HRH1-1, HTH0-2, HTH1-3.
                The HRHs of all controllers are grouped before the HTHs of all controllers
                    (there must not be any HTH of any controller with an object ID lower than
                    that of any HRH configured for this driver).
            [!ENDERROR!]
        [!ENDIF!]
       [!BREAK!]
       [!ENDIF!]
    [!ENDLOOP!]
    [!ENDFOR!]
[!ENDLOOP!]
[!ENDNOCODE!]
/**@}*/

[!NOCODE!]
[!LOOP "CanConfigSet/*"!]
[!LOOP "CanHardwareObject/*"!]
        [!IF "@index > 0"!]
          [!FOR "x" = "0" TO "num:i(@index)"!]
            [!IF "num:i(CanObjectId) = num:i(../*[position() = ($x+1)]/CanObjectId)"!]
                [!IF "contains(node:path(node:ref(CanControllerRef)), node:path(node:ref(../*[position() = ($x+1)]/CanControllerRef)))"!]
                [!ELSE!]
                    [!ERROR!]
                    If Multiplex transmission = ON, the Hardware Objects that has the same CanObjectId must refer to the same controller, and must be of type TRANSMIT.
                    CanHardwareOblect '[!"node:name(.)"!]' and '[!"node:name(../*[position() = ($x+1)])"!]' have the same CanObjectId but refer to different controllers.
                    [!ENDERROR!]
                [!ENDIF!]
            [!ENDIF!]
          [!ENDFOR!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDLOOP!]
[!ENDNOCODE!]
/**
@brief    Extended identifiers.
           - (STD_ON)  - if at least one extended identifier is used.
           - (STD_OFF) - if no extended identifiers are used at all
          If no extended identifiers are used then the IDs and MASKs can be stored in uint16 rather than uint32.
*/
#define CAN_EXTENDEDID [!IF "CanGeneral/CanExtendedIDSupport = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Switches the Development Error Detection and Notification ON or OFF.
@brief    (CAN028) Call the Development Error Tracer when DET is switched on and the Can module detects an error.
@brief    (CAN082) The detection of development errors is configurable (ON / OFF) at pre- compile time.
            The switch CanDevErrorDetection (see chapter 10) shall activate or deactivate the detection of all development errors.
@remarks  Covers CAN028, CAN082
@remarks  Implements DCAN00028, DCAN00082
*/
#define CAN_DEV_ERROR_DETECT [!IF "CanGeneral/CanDevErrorDetection = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    CAN driver support for wakeup over CAN Bus.
*/
#define CAN_WAKEUP_SUPPORT [!IF "CanGeneral/CanWakeupSupport = 'true'"!][!IF "ecu:get('Can.CanConfig.InternalWakeupSupport')='STD_ON' and ecu:get('Can.CanConfig.ExternalWakeupSupport')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Extended number of can hardware objects:
           - STD_ON if more than 256 can hardware objects are needed (up to 65536)
           - STD_OFF if no more than 256 can hardware objects are needed
          The specification only allows up to 256 can hardware objects. The driver supports a non-standard extension of this limit.
*/
#define CAN_MBCOUNTEXTENSION [!IF "CanGeneral/CanMBCountExtensionSupport = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Support for version info API
@brief    (CAN252) The function Can_GetGetVersionInfo shall be pre compile time configurable On/Off by the configuration parameter: CanVersionInfoApi.
@remarks  Covers CAN252
@remarks  Implements DCAN00252
*/
#define CAN_VERSION_INFO_API [!IF "CanGeneral/CanVersionInfoApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Support for Multiplexed Transmision - MB set for Tx is put on bus from any TxMB that is available (free).
@brief    (CAN277) The Can module shall allow that the functionality Multiplexed Transmission is statically configurable (ON | OFF) at pre-compile time.
@remarks  Covers CAN277
@remarks  Implements DCAN00277
*/
#define CAN_TXMUX_SUPPORTED [!IF "CanGeneral/CanMultiplexedTransmission = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Support for Transmision Cancellation
@brief    (CAN278) The Can module shall allow that the functionality Transmit Cancellation is statically configurable (ON | OFF) at pre-compile time.
@remarks  Covers CAN278
@remarks  Implements DCAN00278
*/
#define CAN_TXCANCEL_SUPPORTED [!IF "CanGeneral/CanHardwareCancellation = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Support for Special MB Abort API
@brief    Enable an additional API, to write an ABORT code (b1001) to the MBCB filed of the MB to abort a message transmission.
*/
#define CAN_API_ENABLE_ABORT_MB [!IF "(CanGeneral/CanHardwareCancellation = 'true') and (CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/**
@brief    Instance # of the driver - used for Det_ReportError().
*/
#define CAN_INSTANCE (uint8)[!"num:i(CanGeneral/CanIndex)"!]U


/**
@brief    Platform support mix of controllers with 64 and 32 MBs.
*/
#define CAN_MIX_MB_SUPPORT  [!IF "ecu:get('Can.CanConfig.MixMB')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@{
@brief    Maximum number of Message Buffers configured.
*/[!VAR "max_ctrl" = "ecu:get('Can.CanConfigSet.CanController')"!]
[!LOOP "CanConfigSet/*"!][!VAR "ctrls" = "num:i(count(CanController/*))"!][!VAR "mbs" = "num:i(count(CanHardwareObject/*))"!]
[!IF "( ($ctrls > $max_ctrl) or ($mbs > ($ctrls*(ecu:get('Can.CanConfigSet.CanMB')))) )"!]
    [!ERROR!]Too many MBs for the number of controllers configured.[!ENDERROR!]
[!ELSE!]#define CAN_MAXMBCOUNT_[!"@index"!] (Can_HWObjectCountType)[!"num:i(count(CanHardwareObject/*))"!]U[!ENDIF!]
[!ENDLOOP!]
/**@}*/

/**
@brief    Maximum possible Message Buffers per controller specific to this platform.
*/
#define CAN_MAXMB_SUPPORTED [!"num:i(ecu:get('Can.CanConfigSet.CanMB'))"!]U

/**
@brief    Maximum possible CAN controllers per specific derivative.
*/
#define CAN_MAXCTRL_SUPPORTED (uint8)[!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!]U

/**
@{
@brief    Maximum No. of supported CAN controllers (vary according to Processor Family).
*/[!IF "IMPLEMENTATION_CONFIG_VARIANT='VariantPreCompile'"!]
[!SELECT "CanConfigSet/*[1]"!][!VAR "ctrls" = "num:i(count(CanController/*))"!]
[!IF "$ctrls > $max_ctrl"!][!ERROR!]Target supports maximum [!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!] controllers.[!ENDERROR!]
[!ELSE!]#define CAN_MAXCONTROLLERCOUNT_0 (uint8)[!"$ctrls"!]U[!ENDIF!][!ENDSELECT!]
[!ELSE!]
[!LOOP "CanConfigSet/*"!][!VAR "ctrls" = "num:i(count(CanController/*))"!]
[!IF "$ctrls > $max_ctrl"!][!ERROR!]Target supports maximum [!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!] controllers.[!ENDERROR!]
[!ELSE!]#define CAN_MAXCONTROLLERCOUNT_[!"@index"!] (uint8)[!"$ctrls"!]U[!ENDIF!][!ENDLOOP!]
[!ENDIF!]
/**@}*/


/**
@brief    (CAN099) The hardware events may be detected by an interrupt or by polling status flags of the hardware objects.
          The configuration possibilities regarding polling is hardware dependent (i.e. which events can be polled, which events need to be polled), and not restricted by this standard.
@brief    (CAN007)It shall be possible to configure the driver such that no interrupts at all are used (complete polling).
@remarks  Covers CAN099, CAN007
@remarks  Implements DCAN00099, DCAN00007
*/
[!NOCODE!][!VAR "int_en_a"="0"!][!VAR "int_en_b"="0"!][!VAR "int_en_c"="0"!][!VAR "int_en_d"="0"!][!VAR "int_en_e"="0"!][!VAR "int_en_f"="0"!][!VAR "pol_en"="0"!]
[!SELECT "CanConfigSet/*[1]"!]
    [!LOOP "CanController/*"!]
        [!IF "CanTxProcessing = 'Polling'"!][!VAR "pol_en" = "1"!][!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanTxProcessing = 'Interrupt'"!][!VAR "int_en_a" = "1"!]
            [!ELSE!][!VAR "int_en_a" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanTxProcessing = 'Interrupt'"!][!VAR "int_en_b" = "1"!]
            [!ELSE!][!VAR "int_en_b" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanTxProcessing = 'Interrupt'"!][!VAR "int_en_c" = "1"!]
            [!ELSE!][!VAR "int_en_c" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanTxProcessing = 'Interrupt'"!][!VAR "int_en_d" = "1"!]
            [!ELSE!][!VAR "int_en_d" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanTxProcessing = 'Interrupt'"!][!VAR "int_en_e" = "1"!]
            [!ELSE!][!VAR "int_en_e" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanTxProcessing = 'Interrupt'"!][!VAR "int_en_f" = "1"!]
            [!ELSE!][!VAR "int_en_f" = "2"!][!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!][!ENDNOCODE!]
/**
@{
@brief    These macros enable Interrupts for controllers if Tx processing is set to Interrupt Mode. */
[!IF "$int_en_a!=0"!]#define CAN_A_TXINT_SUPPORTED  [!IF "$int_en_a = 1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_TXINT_SUPPORTED  [!IF "$int_en_b = 1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_TXINT_SUPPORTED  [!IF "$int_en_c = 1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_TXINT_SUPPORTED  [!IF "$int_en_d = 1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_TXINT_SUPPORTED  [!IF "$int_en_e = 1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_TXINT_SUPPORTED  [!IF "$int_en_f = 1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
/**@}*/

/**
@brief    This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in Polling Mode.
*/
#define CAN_TXPOLL_SUPPORTED   [!IF "$pol_en = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

[!NOCODE!][!VAR "int_en_a"="0"!][!VAR "int_en_b"="0"!][!VAR "int_en_c"="0"!][!VAR "int_en_d"="0"!][!VAR "int_en_e"="0"!][!VAR "int_en_f"="0"!][!VAR "pol_en"="0"!]
[!SELECT "CanConfigSet/*[1]"!]
    [!LOOP "CanController/*"!]
        [!IF "CanRxProcessing = 'Polling'"!][!VAR "pol_en" = "1"!][!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanRxProcessing = 'Interrupt'"!][!VAR "int_en_a" = "1"!]
            [!ELSE!][!VAR "int_en_a" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanRxProcessing = 'Interrupt'"!][!VAR "int_en_b" = "1"!]
            [!ELSE!][!VAR "int_en_b" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanRxProcessing = 'Interrupt'"!][!VAR "int_en_c" = "1"!]
            [!ELSE!][!VAR "int_en_c" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanRxProcessing = 'Interrupt'"!][!VAR "int_en_d" = "1"!]
            [!ELSE!][!VAR "int_en_d" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanRxProcessing = 'Interrupt'"!][!VAR "int_en_e" = "1"!]
            [!ELSE!][!VAR "int_en_e" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanRxProcessing = 'Interrupt'"!][!VAR "int_en_f" = "1"!]
            [!ELSE!][!VAR "int_en_f" = "2"!][!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!][!ENDNOCODE!]

/**
@{
@brief    These macros enable Interrupts for controllers if Rx processing is set to Interrupt Mode.
*/
[!IF "$int_en_a!=0"!]#define CAN_A_RXINT_SUPPORTED  [!IF "$int_en_a = 1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_RXINT_SUPPORTED  [!IF "$int_en_b = 1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_RXINT_SUPPORTED  [!IF "$int_en_c = 1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_RXINT_SUPPORTED  [!IF "$int_en_d = 1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_RXINT_SUPPORTED  [!IF "$int_en_e = 1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_RXINT_SUPPORTED  [!IF "$int_en_f = 1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
/**@}*/

/**
@brief    This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in Polling Mode.
*/
#define CAN_RXPOLL_SUPPORTED   [!IF "$pol_en = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

[!NOCODE!][!VAR "int_en_a"="0"!][!VAR "int_en_b"="0"!][!VAR "int_en_c"="0"!][!VAR "int_en_d"="0"!][!VAR "int_en_e"="0"!][!VAR "int_en_f"="0"!][!VAR "pol_en"="0"!]
[!SELECT "CanConfigSet/*[1]"!]
    [!LOOP "CanController/*"!]
        [!IF "CanBusoffProcessing = 'Polling'"!][!VAR "pol_en" = "1"!][!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanBusoffProcessing = 'Interrupt'"!][!VAR "int_en_a" = "1"!]
            [!ELSE!][!VAR "int_en_a" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanBusoffProcessing = 'Interrupt'"!][!VAR "int_en_b" = "1"!]
            [!ELSE!][!VAR "int_en_b" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanBusoffProcessing = 'Interrupt'"!][!VAR "int_en_c" = "1"!]
            [!ELSE!][!VAR "int_en_c" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanBusoffProcessing = 'Interrupt'"!][!VAR "int_en_d" = "1"!]
            [!ELSE!][!VAR "int_en_d" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanBusoffProcessing = 'Interrupt'"!][!VAR "int_en_e" = "1"!]
            [!ELSE!][!VAR "int_en_e" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanBusoffProcessing = 'Interrupt'"!][!VAR "int_en_f" = "1"!]
            [!ELSE!][!VAR "int_en_f" = "2"!][!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!][!ENDNOCODE!]
/**
@{
@brief    These macros enable Interrupts for controllers if BusOff processing is set to Interrupt Mode.
*/
[!IF "$int_en_a!=0"!]#define CAN_A_BUSOFFINT_SUPPORTED  [!IF "$int_en_a = 1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_BUSOFFINT_SUPPORTED  [!IF "$int_en_b = 1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_BUSOFFINT_SUPPORTED  [!IF "$int_en_c = 1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_BUSOFFINT_SUPPORTED  [!IF "$int_en_d = 1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_BUSOFFINT_SUPPORTED  [!IF "$int_en_e = 1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_BUSOFFINT_SUPPORTED  [!IF "$int_en_f = 1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
/**@}*/

/**
@brief    This macro enables Can_MainFunction_BusOff() if at least one controller is set to process BusOff in Polling Mode.
*/
#define CAN_BUSOFFPOLL_SUPPORTED   [!IF "$pol_en = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

[!NOCODE!][!VAR "int_en_a"="0"!][!VAR "int_en_b"="0"!][!VAR "int_en_c"="0"!][!VAR "int_en_d"="0"!][!VAR "int_en_e"="0"!][!VAR "int_en_f"="0"!][!VAR "pol_en"="0"!]
[!SELECT "CanConfigSet/*[1]"!]
    [!LOOP "CanController/*"!]
        [!IF "CanWakeupProcessing = 'Polling'"!][!VAR "pol_en" = "1"!][!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanWakeupProcessing = 'Interrupt'"!][!VAR "int_en_a" = "1"!]
            [!ELSE!][!VAR "int_en_a" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanWakeupProcessing = 'Interrupt'"!][!VAR "int_en_b" = "1"!]
            [!ELSE!][!VAR "int_en_b" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanWakeupProcessing = 'Interrupt'"!][!VAR "int_en_c" = "1"!]
            [!ELSE!][!VAR "int_en_c" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanWakeupProcessing = 'Interrupt'"!][!VAR "int_en_d" = "1"!]
            [!ELSE!][!VAR "int_en_d" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanWakeupProcessing = 'Interrupt'"!][!VAR "int_en_e" = "1"!]
            [!ELSE!][!VAR "int_en_e" = "2"!][!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanWakeupProcessing = 'Interrupt'"!][!VAR "int_en_f" = "1"!]
            [!ELSE!][!VAR "int_en_f" = "2"!][!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!][!ENDNOCODE!]
/**
@{
@brief    These macros enable Interrupts for controllers if Wakeup processing is set to Interrupt Mode.
*/
[!IF "$int_en_a!=0"!]#define CAN_A_WAKEUPINT_SUPPORTED  [!IF "$int_en_a = 1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_WAKEUPINT_SUPPORTED  [!IF "$int_en_b = 1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_WAKEUPINT_SUPPORTED  [!IF "$int_en_c = 1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_WAKEUPINT_SUPPORTED  [!IF "$int_en_d = 1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_WAKEUPINT_SUPPORTED  [!IF "$int_en_e = 1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_WAKEUPINT_SUPPORTED  [!IF "$int_en_f = 1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!](STD_OFF)[!ENDIF!][!ENDIF!]
/**@}*/


/**
@brief    This macro enables Can_MainFunction_Wakeup() if at least one controller is set to process WakeUp in Polling Mode.
*/
#define CAN_WAKEUPPOLL_SUPPORTED   [!IF "$pol_en = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@{
@brief    Maximum number of MB Filters configured.
*/[!LOOP "CanConfigSet/*"!]
#define CAN_MAXFILTERCOUNT_[!"@index"!] (Can_HWObjectCountType)[!"num:i(count(CanController/*/CanFilterMask/*))"!]U
[!ENDLOOP!]
/**@}*/

/**
@{
@brief    Maximum number of Filters configured for RxFifo.
*/[!NOCODE!][!LOOP "CanConfigSet/*"!][!VAR "TableIdCount" = "0"!]
[!LOOP "CanController/*"!][!IF "CanControllerRxFifoEnable = 'true'"!][!VAR "TableIdCount" = "$TableIdCount+8"!][!ENDIF!][!ENDLOOP!]
[!IF "$TableIdCount != 0"!][!CODE!]
#define CAN_MAXTABLEID_[!"@index"!] (uint8)[!"num:i($TableIdCount)"!]U[!ENDCODE!][!ENDIF!][!ENDLOOP!][!ENDNOCODE!]
/**@}*/

[!VAR "rxfifoenable" = "0"!][!LOOP "CanConfigSet/*/CanController/*"!][!IF "CanControllerRxFifoEnable = 'true'"!][!VAR "rxfifoenable" = "1"!][!ENDIF!][!ENDLOOP!]
/**
@brief    Support for Rx Fifo - If at least one controller supports RxFifo, then this define is set to STD_ON.
          This define is global for the entire hardware unit (all controllers). Every controller has particular
          configuration for Rx Fifo (see Can_ControllerConfigType structure).
*/
#define CAN_RXFIFO_ENABLE [!IF "$rxfifoenable = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Set if Rx Fifo events (Warning/Overflow/FrameAvailable) are configured on the same int on INTC vector table.
          Based on this define separate interrupts handlers or not will be used for the 3 events of the RxFifo.
*/
#define CAN_RXFIFO_EVENT_UNIFIED [!IF "ecu:get('Can.CanConfigSet.RxFifoEventsUnified')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Indexes used for accessing the 'Can_ControlerDescriptorType' structure. NOTE that index order from hardware (where CAN_A has always index 0, ..)
            may not be the same with the order from the 'Can_ControlerDescriptorType' structure (where user can define controllers in any order).
          Count also the number of controllers that have interrupts enabled.
*/
[!SELECT "CanConfigSet/*[1]"!][!LOOP "CanController/*"!]
[!IF "CanHwChannel = 'FlexCAN_A'"!]
/**
@brief    Index into the configuration structure.
          Can controllers can be declared in the Tressos plugin configuration in any order.
          Not necessary to have FLEXCAN_A on the first place. Some Can driver configurations can use only FLEXCAN_B for example.
*/
#define CAN_FCA_INDEX       (uint8)[!"num:i(CanControllerId)"!]U

/**
@brief    Index into the hardware platform.
*/
#define FLEXCAN_A_OFFSET    (uint8)0U

/**
@brief    RxFifo Functionality enabled/disabled. Used for Interrupts mapping in Can_Irq.c file.
          Every controller can have separate RxFifo enabled/disabled reported to other controllers.
*/
#define CAN_A_FIFO_EN       [!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!ELSEIF "CanHwChannel = 'FlexCAN_B'"!]
/**
@brief    Index into the configuration structure.
          Can controllers can be declared in the Tressos plugin configuration in any order.
          Not necessary to have FLEXCAN_A on the first place. Some Can driver configurations can use only FLEXCAN_B for example.
*/
#define CAN_FCB_INDEX       (uint8)[!"num:i(CanControllerId)"!]U

/**
@brief    Index into the hardware platform.
*/
#define FLEXCAN_B_OFFSET    (uint8)1U

/**
@brief    RxFifo Functionality enabled/disabled. Used for Interrupts mapping in Can_Irq.c file.
          Every controller can have separate RxFifo enabled/disabled reported to other controllers.
*/
#define CAN_B_FIFO_EN       [!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!ELSEIF "CanHwChannel = 'FlexCAN_C'"!]
/**
@brief    Index into the configuration structure.
          Can controllers can be declared in the Tressos plugin configuration in any order.
          Not necessary to have FLEXCAN_A on the first place. Some Can driver configurations can use only FLEXCAN_B for example.
*/
#define CAN_FCC_INDEX       (uint8)[!"num:i(CanControllerId)"!]U

/**
@brief    Index into the hardware platform.
*/
#define FLEXCAN_C_OFFSET    (uint8)2U

/**
@brief    RxFifo Functionality enabled/disabled. Used for Interrupts mapping in Can_Irq.c file.
          Every controller can have separate RxFifo enabled/disabled reported to other controllers.
*/
#define CAN_C_FIFO_EN       [!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!ELSEIF "CanHwChannel = 'FlexCAN_D'"!]
/**
@brief    Index into the configuration structure.
*/
#define CAN_FCD_INDEX       (uint8)[!"num:i(CanControllerId)"!]U

/**
@brief    Index into the hardware platform.
*/
#define FLEXCAN_D_OFFSET    (uint8)3U

/**
@brief    RxFifo Functionality enabled/disabled. Used for Interrupts mapping in Can_Irq.c file.
          Every controller can have separate RxFifo enabled/disabled reported to other controllers.
*/
#define CAN_D_FIFO_EN       [!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!ELSEIF "CanHwChannel = 'FlexCAN_E'"!]
/**
@brief    Index into the configuration structure.
          Can controllers can be declared in the Tressos plugin configuration in any order.
          Not necessary to have FLEXCAN_A on the first place. Some Can driver configurations can use only FLEXCAN_B for example.
*/
#define CAN_FCE_INDEX       (uint8)[!"num:i(CanControllerId)"!]U

/**
@brief    Index into the hardware platform.
*/
#define FLEXCAN_E_OFFSET    (uint8)4U

/**
@brief    RxFifo Functionality enabled/disabled. Used for Interrupts mapping in Can_Irq.c file.
          Every controller can have separate RxFifo enabled/disabled reported to other controllers.
*/
#define CAN_E_FIFO_EN       [!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!ELSEIF "CanHwChannel = 'FlexCAN_F'"!]
/**
@brief    Index into the configuration structure.
          Can controllers can be declared in the Tressos plugin configuration in any order.
          Not necessary to have FLEXCAN_A on the first place. Some Can driver configurations can use only FLEXCAN_B for example.
*/
#define CAN_FCF_INDEX       (uint8)[!"num:i(CanControllerId)"!]U

/**
@brief    Index into the hardware platform.
*/
#define FLEXCAN_F_OFFSET    (uint8)5U

/**
@brief    RxFifo Functionality enabled/disabled. Used for Interrupts mapping in Can_Irq.c file.
          Every controller can have separate RxFifo enabled/disabled reported to other controllers.
*/
#define CAN_F_FIFO_EN       [!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!ENDIF!][!ENDLOOP!][!ENDSELECT!]


/**
@brief    Optimization of interrupt service code for size.
          All MBs are handled by the same interrupt routine.
*/
#define CAN_ISROPTCODESIZE [!IF "CanGeneral/CanCodeSizeOptimization = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief    Enable Non-Autosar API for Dual-Clock support.
          This can be set to STD_ON only if it is activated from Resource file (Can.CanConfig.DualClockMode = STD_ON)
*/
#define CAN_DUAL_CLOCK_MODE [!IF "ecu:get('Can.CanConfig.DualClockMode')='STD_ON'"!][!IF "CanGeneral/CanEnableDualClockMode = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!ELSE!](STD_OFF)[!ENDIF!]


/**
@brief   Maximum number of tight SW loops to execute while waiting for a state change
@brief   (CAN281) The Can module shall contain a timeout detection in case the hardware doesn't react in the expected time (hardware error) to prevent endless loops.
         As long as the system service does not provide a free running timer this timeout shall be realized with a fixed number of loops.
@brief   (CAN296)In that case, the Can module shall poll a flag of the CAN status register until the flag signals that the change takes affect and then return.
@remarks Covers CAN281, CAN296
@remarks Implements DCAN00281, DCAN00296
*/
#define CAN_TIMEOUT_DURATION [!SELECT "CanGeneral"!](uint32)[!"num:i(CanTimeoutDurationFactor)"!]U[!ENDSELECT!]

[!IF "IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile'"!]
/**
@brief   Precompile Support ON.
@brief   (CAN220)VariantPC: all variables are pre-compile time configurable.
@remarks Covers CAN220
@remarks Implements DCAN00220
*/
#define CAN_PRECOMPILE_SUPPORT
[!ELSE!]
/**
@brief   PostBuild Support On.
@brief   (CAN221)VariantPB: (Mix of precompile and Post Build multiple selectableconfigurable configurations
@remarks Covers CAN221
@remarks Implements DCAN00221
*/
/* CAN_PRECOMPILE_SUPPORT must be defined only for Pre-Compile version. */
[!ENDIF!]


/**
@brief    Export Can_ConfigType structure. This is the type of the external data structure containing
            the overall initialization data for the CAN driver and affecting all controllers.
*/[!IF "IMPLEMENTATION_CONFIG_VARIANT='VariantPostBuild'"!]
#ifndef CAN_PRECOMPILE_SUPPORT
[!NOCODE!][!VAR "var_count1"="num:i(count(CanConfigSet/*))"!][!VAR "w"="0"!][!ENDNOCODE!]
  /* Export Driver configuration */
  #define CAN_INIT_CONFIG_PB_DEFINES \[!LOOP "CanConfigSet/*"!][!VAR "w"="$w + 1"!]
    extern CONST(Can_ConfigType, CAN_CONST) [!"@name"!]; [!IF "$w < $var_count1"!] \[!ENDIF!][!ENDLOOP!]

[!NOCODE!][!VAR "var_count1"="num:i(count(CanConfigSet/*))"!][!VAR "w"="0"!][!ENDNOCODE!]
  /* Export Controllers configuration */
  #define CAN_INIT_CONFIG_CONTROLLERS_PB \[!LOOP "CanConfigSet/*"!][!VAR "w"="$w + 1"!]
    extern CONST(Can_ControllerConfigType, CAN_CONST) ControllerConfigs[!"@index"!]_PB[CAN_MAXCONTROLLERCOUNT_[!"@index"!]];[!IF "$w < $var_count1"!] \[!ENDIF!][!ENDLOOP!]

#endif
[!ELSE!]
#ifdef CAN_PRECOMPILE_SUPPORT

  /* Export Driver configuration */
  #define CAN_INIT_CONFIG_PC_DEFINES \
    extern CONST(Can_ConfigType, CAN_CONST) Can_ConfigSet_PC;

  /* Export Controllers configuration */
  #define CAN_INIT_CONFIG_CONTROLLERS_PC \
    extern CONST(Can_ControllerConfigType, CAN_CONST) ControllerConfigs_PC[CAN_MAXCONTROLLERCOUNT_0];

#endif
[!ENDIF!]

/**
@brief    Periods for cyclic call of Main function
@brief    (CAN355)CanMainFunctionBusoffPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Busoff. Unit is seconds.
@remarks  Covers CAN355
@remarks  Implements DCAN00355
*/
#define CAN_MAINFUNCTION_PERIOD_BUSOFF  [!SELECT "CanGeneral"!](uint32)[!"CanMainFunctionBusoffPeriod"!]U[!ENDSELECT!]

/**
@brief    Periods for cyclic call of Main function
@brief    (CAN356)CanMainFunctionReadPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Read. Unit is seconds.
@remarks  Covers CAN356
@remarks  Implements DCAN00356
*/
#define CAN_MAINFUNCTION_PERIOD_READ    [!SELECT "CanGeneral"!](uint32)[!"CanMainFunctionReadPeriod"!]U[!ENDSELECT!]

/**
@brief    Periods for cyclic call of Main function
@brief    (CAN357)CanMainFunctionWakeupPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Wakeup. Unit is seconds.
@remarks  Covers CAN357
@remarks  Implements DCAN00357
*/
#define CAN_MAINFUNCTION_PERIOD_WAKEUP  [!SELECT "CanGeneral"!](uint32)[!"CanMainFunctionWakeupPeriod"!]U[!ENDSELECT!]

/**
@brief    Periods for cyclic call of Main function
@brief    (CAN358)CanMainFunctionWritePeriod - This parameter describes the period for cyclic call to Can_MainFunction_Write. Unit is seconds.
@remarks  Covers CAN358
@remarks  Implements DCAN00358
*/
#define CAN_MAINFUNCTION_PERIOD_WRITE   [!SELECT "CanGeneral"!](uint32)[!"CanMainFunctionWritePeriod"!]U[!ENDSELECT!]


/**
@brief    WakeUp support settings.
          Internal Wakeup is triggered by WakeUp bits Interrupt from IntVectorTable.
*/
#define CAN_WKP_INT_SUPPORT   [!IF "CanGeneral/CanWakeupSupport='true'"!][!IF "ecu:get('Can.CanConfig.InternalWakeupSupport')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!ELSE!](STD_OFF)[!ENDIF!]
/**
@brief    WakeUp support settings.
          External Wakeup is supported by Rx pin through WAKEUP_UNIT module.
*/
#define CAN_WKP_EXT_SUPPORT   [!IF "CanGeneral/CanWakeupSupport='true'"!][!IF "ecu:get('Can.CanConfig.ExternalWakeupSupport')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!ELSE!](STD_OFF)[!ENDIF!]

[!NOCODE!]
[!IF "ecu:get('Can.CanConfig.ExternalWakeupSupport') = 'STD_ON'"!]
    [!SELECT "CanConfigSet/*[1]"!]
        [!LOOP "CanController/*"!]
            [!IF "CanControllerExternalWakeupCh='WKPU0' or CanControllerExternalWakeupCh='WKPU1' or CanControllerExternalWakeupCh='WKPU2' or CanControllerExternalWakeupCh='WKPU3' or CanControllerExternalWakeupCh='WKPU4' or CanControllerExternalWakeupCh='WKPU5' or CanControllerExternalWakeupCh='WKPU6' or CanControllerExternalWakeupCh='WKPU7'"!]
/**
@brief    Macro used only if External Wakeup is enabled (emualtion of Internal Wakeup using WKPU module).
           This should be STD_ON if at least one CAN has assigned a WKPU source between WKUP[0] - WKUP[7].
*/
#define WKPU_INT_VECTOR0  [!IF "$v0 = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
            [!ENDIF!]
            [!IF "CanControllerExternalWakeupCh='WKPU8' or CanControllerExternalWakeupCh='WKPU9' or CanControllerExternalWakeupCh='WKPU10' or CanControllerExternalWakeupCh='WKPU11' or CanControllerExternalWakeupCh='WKPU12' or CanControllerExternalWakeupCh='WKPU13' or CanControllerExternalWakeupCh='WKPU14' or CanControllerExternalWakeupCh='WKPU15'"!]
/**
@brief    Macro used only if External Wakeup is enabled (emualtion of Internal Wakeup using WKPU module).
           This should be STD_ON if at least one CAN has assigned a WKPU source between WKUP[8] - WKUP[15].
*/
#define WKPU_INT_VECTOR1  [!IF "$v1 = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
            [!ENDIF!]
            [!IF "CanControllerExternalWakeupCh='WKPU16' or CanControllerExternalWakeupCh='WKPU17' or CanControllerExternalWakeupCh='WKPU18' or CanControllerExternalWakeupCh='WKPU19' or CanControllerExternalWakeupCh='WKPU20' or CanControllerExternalWakeupCh='WKPU21' or CanControllerExternalWakeupCh='WKPU22' or CanControllerExternalWakeupCh='WKPU23'"!]
/**
@brief    Macro used only if External Wakeup is enabled (emualtion of Internal Wakeup using WKPU module).
           This should be STD_ON if at least one CAN has assigned a WKPU source between WKUP[16] - WKUP[23].
*/
#define WKPU_INT_VECTOR2  [!IF "$v2 = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
            [!ENDIF!]
            [!IF "CanControllerExternalWakeupCh='WKPU24' or CanControllerExternalWakeupCh='WKPU25' or CanControllerExternalWakeupCh='WKPU26' or CanControllerExternalWakeupCh='WKPU27' or CanControllerExternalWakeupCh='WKPU28' or CanControllerExternalWakeupCh='WKPU29' or CanControllerExternalWakeupCh='WKPU30' or CanControllerExternalWakeupCh='WKPU31'"!]
/**
@brief    Macro used only if External Wakeup is enabled (emualtion of Internal Wakeup using WKPU module).
           This should be STD_ON if at least one CAN has assigned a WKPU source between WKUP[24] - WKUP[31].
*/
#define WKPU_INT_VECTOR3  [!IF "$v3 = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDSELECT!]
[!ENDIF!]
[!ENDNOCODE!]


[!VAR "BccSupport" = "0"!][!LOOP "CanConfigSet/*/CanController/*"!][!IF "CanBccSupport = 'true'"!][!VAR "BccSupport" = "1"!][!ENDIF!][!ENDLOOP!]
/**
@brief    Defines if Backwards Compatibility Configuration (BCC) feature of CAN controller is used in the configuration.
          If BCC feature of CAN controller is enabled, Individual Rx masking and queue feature are disabled.
          If BCC feature of CAN controller is disabled, Individual Rx masking and queue feature are enabled.
*/
#define CAN_BCC_SUPPORT_ENABLE [!IF "$BccSupport = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
[!NOCODE!]
[!VAR "Can_hardware_ob_id" = "0"!]
[!LOOP "CanConfigSet/*/CanHardwareObject/*"!]
[!IF "$Can_hardware_ob_id < CanObjectId"!]
[!VAR "Can_hardware_ob_id" = "CanObjectId"!]
[!ENDIF!]
[!ENDLOOP!][!ENDNOCODE!]
/**
@brief    Macro used to define the maximum of Can object IDs configured  .
*/
#define CAN_MAX_OBJECT_ID (Can_HWObjectCountType)[!"num:i($Can_hardware_ob_id + 1)"!]U


#endif /* _CAN_CFG_H_ */
